Define strict Workout schema + adapter for old data

Goal: Guarantee we never ship an “empty plan”. Add runtime validation and a small adapter so older saved workouts still render.

Create shared/workoutSchema.ts (shared by server & client):

// shared/workoutSchema.ts
import { z } from "zod";

export const MovementZ = z.object({
  id: z.string(),                  // "pushup"
  name: z.string(),                // "Push-up"
  equipment: z.array(z.string()),  // ["bodyweight"] | ["dumbbell"] | ["kettlebell"] | ["barbell"]
  tags: z.array(z.string()),       // ["push","upper","hinge","core","mono","warmup"]
});

export const PrescriptionZ = z.object({
  type: z.enum(["reps","time","distance"]), // dosing modality
  sets: z.number().int().min(1),            // 3
  reps: z.number().int().min(1).optional(), // if type="reps"
  seconds: z.number().int().min(5).optional(), // if type="time"
  meters: z.number().int().min(10).optional(), // if type="distance"
  load: z.string().optional(),              // "2x20lb", "bodyweight", "RPE 8"
  restSec: z.number().int().min(0).default(0),
  tempo: z.string().optional(),             // "30X1"
  notes: z.string().optional(),
});

export const BlockItemZ = z.object({
  movementId: z.string(),           // references MovementZ.id
  name: z.string(),
  prescription: PrescriptionZ,
});

export const BlockZ = z.object({
  key: z.enum(["warmup","main","cooldown","accessory"]).or(z.string()),
  title: z.string(),
  items: z.array(BlockItemZ).min(1),   // never empty
  targetSeconds: z.number().int().min(60), // planned time for block
  style: z.enum(["straight-sets","emom","amrap","interval","circuit"]).optional(),
});

export const WorkoutPlanZ = z.object({
  id: z.string().optional(),        // will exist after save
  seed: z.string(),                 // for determinism
  focus: z.enum(["strength","conditioning","mixed","endurance"]),
  durationMin: z.number().int().min(10).max(120),
  intensity: z.number().int().min(1).max(10),
  equipment: z.array(z.string()),   // from user
  blocks: z.array(BlockZ).min(2),
  totalSeconds: z.number().int().min(300),
  summary: z.string(),              // human synopsis
  version: z.literal(1),
});

export type Movement = z.infer<typeof MovementZ>;
export type WorkoutPlan = z.infer<typeof WorkoutPlanZ>;


Create server/workouts/adapter.ts to handle any older saved shape:

import { WorkoutPlanZ } from "../../shared/workoutSchema";
export function adaptToPlanV1(raw: any) {
  // try to coerce older shapes; ensure blocks[].items present
  // add conservative defaults if missing
  const plan = WorkoutPlanZ.parse(raw);
  return plan;
}


Fail fast: where we return preview/save, validate with WorkoutPlanZ.parse(plan) before responding.

Acceptance

Any preview with 200 must satisfy WorkoutPlanZ and have blocks[].items.length ≥ 1.

If validation fails, return 500 with a readable message and Sentry capture.
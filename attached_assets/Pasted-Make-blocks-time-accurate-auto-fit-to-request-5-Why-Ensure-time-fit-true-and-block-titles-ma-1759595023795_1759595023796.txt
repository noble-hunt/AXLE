Make blocks time-accurate + auto-fit to request (±5%)

Why: Ensure time_fit=true and block titles match their durations.

Files: server/ai/generators/premium.ts

Do this exactly:

Add a small fitter (near the top of the file):

// --- Time fitter: aligns block minutes to requested duration within ±5% ---
function fitBlocksToDuration(blocks: any[], reqDurMin: number, warmupMin: number, cooldownMin: number) {
  const mains = blocks.filter(b => !['warmup','cooldown'].includes(b.kind));
  const header = (mins:number) => Math.max(6, Math.min(30, Math.round(mins))); // sane bounds per block

  // 1) Normalize titles to their minute values (EMOM N, Every 2:00 x sets, etc.)
  for (const b of mains) {
    if (/^EMOM/i.test(b.title)) b.title = `EMOM ${header(b.time_min)}`;
    if (/^Every\s*2:00/i.test(b.title)) b.title = `Every 2:00 x ${Math.round((b.time_min||0)/2)}`;
    if (/^Every\s*2:30/i.test(b.title)) b.title = `Every 2:30 x ${Math.round((b.time_min||0)/2.5)}`;
    if (/^Every\s*3:00/i.test(b.title)) b.title = `Every 3:00 x ${Math.round((b.time_min||0)/3)}`;
    if (/^For\s*Time\s*21-15-9/i.test(b.title)) b.time_min = header(b.time_min || 10);
    if (/^Chipper/i.test(b.title)) b.time_min = header(b.time_min || 12);
  }

  const minNow = (blocks.reduce((t,b)=>t+(b.time_min||0),0));
  const target = reqDurMin;
  const delta = target - minNow;

  // 2) If under target by >5%, extend the longest main or add a finisher
  if (delta > Math.max(2, target*0.05)) {
    const longest = mains.sort((a,b)=>(b.time_min||0)-(a.time_min||0))[0];
    if (longest && /^EMOM/.test(longest.title)) {
      longest.time_min += delta;  // extend EMOM by the deficit
      longest.title = `EMOM ${header(longest.time_min)}`;
    } else {
      // add a 6–8 min finisher
      blocks.splice(blocks.length-1, 0, {
        kind: 'conditioning',
        title: target >= 40 ? 'For Time 30-20-10' : 'For Time 21-15-9',
        time_min: Math.min(8, header(delta)),
        items: (mains[0]?.items||[]).slice(0,2) // reuse first two movements
      });
    }
  }

  // 3) If over target by >5%, trim the longest EMOM/E2:00 block
  if (-delta > Math.max(2, target*0.05)) {
    const longest = mains.sort((a,b)=>(b.time_min||0)-(a.time_min||0))[0];
    if (longest) {
      longest.time_min = header((longest.time_min||0) + delta); // delta is negative
      if (/^EMOM/.test(longest.title)) longest.title = `EMOM ${header(longest.time_min)}`;
    }
  }
}


Call the fitter right before you return the workout (after blocks are assembled):

// Ensure block time alignment
fitBlocksToDuration(workout.blocks, req.duration_min, pack.warmupMin, pack.cooldownMin);

// Recompute acceptance
const totalMin = workout.blocks.reduce((t,b)=>t+(b.time_min||0),0);
workout.acceptance_flags = {
  ...(workout.acceptance_flags||{}),
  time_fit: Math.abs(totalMin - req.duration_min) <= Math.max(2, req.duration_min*0.05)
};


Acceptance: Regenerate Oly/PL/BB; time_fit flips to true and titles align with minutes.
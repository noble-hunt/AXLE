Register Garmin provider (skeleton)

Message to Replit Agent:

Create server/providers/health/garmin.ts implementing the HealthProvider interface.

import { HealthProvider } from "./types";
import { garmin, } from "../../config";
import { makePkce } from "../../lib/pkce";
import { signState, verifyState } from "../../lib/oauthState";
import { saveProviderTokens, getProviderTokens, upsertConnection } from "../../dal/tokens"; // existing DAL
import fetch from "node-fetch";

const AUTH_URL = "https://connect.garmin.com/oauth2Confirm";
const TOKEN_URL = "https://diauth.garmin.com/di-oauth2-service/oauth/token";
const USER_ID_URL = "https://apis.garmin.com/wellness-api/rest/user/id";

export const GarminHealthProvider: HealthProvider = {
  id: "Garmin",
  hasConfig() { return !!(garmin.clientId && garmin.clientSecret && garmin.redirectUrl); },

  async authStart(userId: string) {
    if (!garmin.clientId || !garmin.redirectUrl) throw new Error("Garmin not configured");
    const pkce = makePkce();
    const state = await signState({ u: userId, v: pkce.code_verifier, p: "garmin" });
    const url = new URL(AUTH_URL);
    url.searchParams.set("response_type","code");
    url.searchParams.set("client_id", garmin.clientId);
    url.searchParams.set("code_challenge", pkce.code_challenge);
    url.searchParams.set("code_challenge_method", pkce.method);
    url.searchParams.set("redirect_uri", garmin.redirectUrl);
    url.searchParams.set("state", state);
    return { redirectUrl: url.toString() };
  },

  async authCallback(params, userId: string) {
    const { code, state } = params as Record<string,string>;
    if (!code || !state) throw new Error("Missing code/state");
    const decoded = await verifyState<{u:string; v:string; p:string;}>(state);
    if (decoded.p !== "garmin" || decoded.u !== userId) throw new Error("Bad state");

    const body = new URLSearchParams({
      grant_type: "authorization_code",
      client_id: garmin.clientId,
      client_secret: garmin.clientSecret,
      code,
      code_verifier: decoded.v,
      redirect_uri: garmin.redirectUrl,
    });
    const res = await fetch(TOKEN_URL, {
      method: "POST",
      headers: { "Content-Type": "application/x-www-form-urlencoded" },
      body
    });
    if (!res.ok) throw new Error(`Garmin token exchange failed: ${res.status}`);
    const tok = await res.json();
    // Persist tokens (access/refresh/expiry) via existing sealed DAL
    await saveProviderTokens(userId, "Garmin", {
      access_token: tok.access_token,
      refresh_token: tok.refresh_token,
      expires_in: tok.expires_in,
      obtained_at: Date.now(),
      scope: tok.scope
    });
    await upsertConnection({ userId, provider: "Garmin", status: "connected", last_error: null });
  },

  async fetchLatest(userId: string) {
    const tokens = await getProviderTokens(userId, "Garmin");
    if (!tokens) throw new Error("Not connected");
    // ensure fresh access token
    const accessToken = await ensureGarminAccessToken(tokens);
    // get API user id (stable across tokens)
    const uidRes = await fetch(USER_ID_URL, { headers: { Authorization: `Bearer ${accessToken}` }});
    if (!uidRes.ok) throw new Error(`Garmin user id failed: ${uidRes.status}`);
    const { userId: apiUserId } = await uidRes.json();

    // Pull last 2 days daily summary via backfill (Health API)
    const end = Math.floor(Date.now()/1000);
    const start = end - 2*86400;
    const dailiesUrl = new URL("https://apis.garmin.com/wellness-api/rest/backfill/dailies");
    dailiesUrl.searchParams.set("summaryStartTimeInSeconds", String(start));
    dailiesUrl.searchParams.set("summaryEndTimeInSeconds", String(end));
    const dailiesRes = await fetch(dailiesUrl, { headers: { Authorization: `Bearer ${accessToken}` }});
    if (!dailiesRes.ok) throw new Error(`Garmin dailies failed: ${dailiesRes.status}`);
    const dailies = await dailiesRes.json();

    // Map to HealthSnapshot (robust null guards)
    const latest = Array.isArray(dailies) && dailies.length ? dailies[dailies.length-1] : null;
    const snapshot = {
      providerUserId: apiUserId,
      date: latest?.calendarDate || new Date().toISOString().slice(0,10),
      hrv_ms: latest?.hrvSummary?.avgRmssd || null,
      resting_hr_bpm: latest?.restingHeartRate || null,
      sleep_score: latest?.sleepDurationInSeconds ? Math.round(Math.min(100, (latest.sleepDurationInSeconds/28800)*100)) : null,
      stress: latest?.stressLevel || null,
      steps: latest?.steps || null,
      calories: latest?.calories || null,
      raw: { dailies: latest }
    };
    return snapshot;
  }
};

// token refresh helper
async function ensureGarminAccessToken(tok: any): Promise<string> {
  const now = Date.now()/1000;
  const expiresAt = (tok.obtained_at/1000) + (tok.expires_in ?? 0) - 600; // refresh 10 min early
  if (now < expiresAt && tok.access_token) return tok.access_token;
  const body = new URLSearchParams({
    grant_type: "refresh_token",
    client_id: garmin.clientId,
    client_secret: garmin.clientSecret,
    refresh_token: tok.refresh_token,
  });
  const res = await fetch(TOKEN_URL, { method:"POST", headers:{ "Content-Type":"application/x-www-form-urlencoded" }, body });
  if (!res.ok) throw new Error(`Garmin refresh failed: ${res.status}`);
  const refreshed = await res.json();
  await saveProviderTokens(tok.user_id ?? "", "Garmin", {
    access_token: refreshed.access_token,
    refresh_token: refreshed.refresh_token || tok.refresh_token,
    expires_in: refreshed.expires_in,
    obtained_at: Date.now(),
    scope: refreshed.scope
  });
  return refreshed.access_token;
}


Provider registry: register this provider in your existing providers map, e.g. server/providers/health/index.ts:

import { GarminHealthProvider } from "./garmin";
// ...
providers.push(GarminHealthProvider);


Acceptance Criteria

Build passes.

/api/connect/providers shows “Garmin (Connect)” as Available when env is set.

No lint/type errors.
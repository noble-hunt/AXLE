“Harden workout creation pipeline + fix navigation”

Goal: Ensure POST /api/workouts creates a row and always returns { id }, and the client only navigates to /workout/:id when a valid UUID is present. Also add guards in the detail page to avoid the “Not Found” trap on bad ids.

1) Server: lock down create & always return id

File: server/routes/workouts.ts (or where the POST is defined)

Tasks

Parse the Supabase access token from Authorization: Bearer ....

Resolve userId via Supabase Admin (SUPABASE_SERVICE_ROLE_KEY) to avoid RLS hiccups and client-spoofed ids.

Insert the workout with that userId.

Validate output; if id is missing, throw 500. Return { id } only (and optionally title).

Implementation sketch

import { supabaseAdmin } from "../lib/supabaseAdmin"; // service-role client
import { getBearer } from "../lib/http"; // small helper to read bearer token
import { z } from "zod";

const CreateWorkoutSchema = z.object({
  title: z.string().min(1).max(120).optional(),
  request: z.any().optional(),          // generator params or freeform payload
  planned_intensity: z.number().int().min(1).max(10).optional(),
  perceived_intensity: z.number().int().min(1).max(10).optional(),
  sets: z.any().optional(),
  notes: z.string().max(2000).optional()
});

app.post("/api/workouts", async (req, res) => {
  try {
    const token = getBearer(req.headers.authorization);
    if (!token) return res.status(401).json({ error: "no_auth" });

    const { data: { user }, error: uerr } = await supabaseAdmin.auth.getUser(token);
    if (uerr || !user) return res.status(401).json({ error: "bad_token" });

    const body = CreateWorkoutSchema.parse(req.body ?? {});
    const payload = {
      user_id: user.id,
      title: body.title ?? "Generated Workout",
      request: body.request ?? null,
      sets: body.sets ?? null,
      notes: body.notes ?? null,
      planned_intensity: body.planned_intensity ?? null,
      perceived_intensity: body.perceived_intensity ?? null
    };

    const { data, error } = await supabaseAdmin
      .from("workouts")
      .insert(payload)
      .select("id")
      .single();

    if (error) {
      console.error("[workouts:create] insert error", error);
      return res.status(500).json({ error: "insert_failed" });
    }
    if (!data?.id) {
      console.error("[workouts:create] no id returned");
      return res.status(500).json({ error: "no_id" });
    }
    return res.status(200).json({ id: data.id });
  } catch (e) {
    console.error("[workouts:create] exception", e);
    return res.status(400).json({ error: "bad_request" });
  }
});


Also verify RLS on public.workouts (should already be):

-- Select & insert own rows (kept for non-admin clients)
create policy if not exists "select own workouts"
  on public.workouts for select using (auth.uid() = user_id);
create policy if not exists "insert own workouts"
  on public.workouts for insert with check (auth.uid() = user_id);


(Admin client bypasses RLS anyway, but these help when client uses anon key directly.)

Acceptance (server)

POST returns 200 with { id: "<uuid>" }.

A row appears in public.workouts with your user_id
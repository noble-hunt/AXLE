Provider abstraction + secure storage + mock sync API (STOP after this)

Goal
Add a pluggable provider layer (Apple HealthKit, Garmin, Whoop, Fitbit, Oura). Store connection state + tokens securely. Provide a Mock provider so the feature works today without real keys.

DB
We already have public.wearable_connections and public.health_reports. Add a tokens table and extend connections:

-- 002_health_tokens.sql
create table if not exists public.wearable_tokens (
  id uuid primary key default gen_random_uuid(),
  user_id uuid not null references auth.users(id) on delete cascade,
  provider text not null,
  access_token text not null,           -- encrypted
  refresh_token text,                   -- encrypted
  expires_at timestamptz,
  scope text,
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);
alter table public.wearable_tokens enable row level security;
create policy "tokens owner" on public.wearable_tokens for all
  using (user_id = auth.uid()) with check (user_id = auth.uid());

-- small extension on connections
alter table public.wearable_connections
  add column if not exists provider_user_id text,
  add column if not exists status text default 'disconnected',    -- disconnected|connected|error
  add column if not exists error text;

-- optional daily aggregate for quick charts (kept in health_reports.metrics if you prefer)
-- we’ll keep using health_reports(metrics jsonb) to avoid another table.


Server config

Env:

ENCRYPTION_KEY=<32+ chars> (for AES-256-GCM)

Optional provider creds: FITBIT_CLIENT_ID/SECRET, WHOOP_CLIENT_ID/SECRET, OURA_CLIENT_ID/SECRET, GARMIN_*. If any are missing, the provider should show as “Mock” only.

Crypto helpers
server/lib/crypto.ts:

import crypto from "crypto";
const KEY = Buffer.from(process.env.ENCRYPTION_KEY || "", "utf8");
export function seal(plain: string) {
  const iv = crypto.randomBytes(12);
  const cipher = crypto.createCipheriv("aes-256-gcm", crypto.scryptSync(KEY, "axle", 32), iv);
  const enc = Buffer.concat([cipher.update(plain, "utf8"), cipher.final()]);
  const tag = cipher.getAuthTag();
  return Buffer.concat([iv, tag, enc]).toString("base64");
}
export function open(b64: string) {
  const raw = Buffer.from(b64, "base64");
  const iv = raw.subarray(0, 12);
  const tag = raw.subarray(12, 28);
  const data = raw.subarray(28);
  const decipher = crypto.createDecipheriv("aes-256-gcm", crypto.scryptSync(KEY, "axle", 32), iv);
  decipher.setAuthTag(tag);
  return Buffer.concat([decipher.update(data), decipher.final()]).toString("utf8");
}


Provider abstraction
Create server/providers/health/ with:

types.ts (common normalized metrics)

export type HealthSnapshot = {
  date: string;                 // YYYY-MM-DD
  hrv?: number|null;            // ms
  restingHR?: number|null;      // bpm
  sleepScore?: number|null;     // 0-100
  stress?: number|null;         // 0-10
  steps?: number|null;
  calories?: number|null;
};
export interface HealthProvider {
  id: "Mock"|"Fitbit"|"Whoop"|"Oura"|"Garmin"|"AppleHealth";
  hasConfig(): boolean;
  authStart?(userId: string): Promise<{ redirectUrl: string }>;
  authCallback?(params: Record<string,string>, userId: string): Promise<void>;
  fetchLatest?(userId: string): Promise<HealthSnapshot>;
}


mock.ts (works today): generate plausible data from the user’s last workouts; allow stress flag via querystring for testing.

Stubs fitbit.ts, oura.ts, whoop.ts, garmin.ts with TODOs and hasConfig() returning false unless env vars are present.

Routes
server/routes/health.ts:

GET /api/connect/providers → list providers with { id, supported: boolean, connected, last_sync, status }.

POST /api/connect/:provider/start → if provider Mock, immediately create/update wearable_connections as connected; if real provider with config, return {redirectUrl} to OAuth.

GET /api/connect/:provider/callback → handle OAuth (for Mock, just connect).

POST /api/health/sync (body { provider }) → fetchLatest → upsert health_reports row for today (merge metrics) and update wearable_connections.last_sync.

GET /api/health/reports?days=14 → list recent reports (metrics json).

Acceptance (then STOP)

With only Mock available (no provider keys), /api/connect/providers shows Mock supported and others unsupported.

POST /api/connect/Mock/start marks connection connected.

POST /api/health/sync {provider:'Mock'} inserts/updates health_reports for today with metrics like {HRV, RestingHR, SleepScore, Stress}.

Tokens are encrypted when saved to wearable_tokens (verify column contents look base64 garbage).
Serverless + dev routes (aligned to your endpoints)

Create / Update

1) Transcription — POST /api/stt/whisper

Prod: api/stt/whisper.ts

Dev: server/routes/whisper-transcription.ts and mount at /api/stt

// api/stt/whisper.ts  (Vercel serverless)
import { openai } from '../_openai';
export const config = { runtime: 'nodejs18.x' };

export default async function handler(req: Request) {
  if (req.method !== 'POST') return j({ error: 'Method Not Allowed' }, 405);

  try {
    const ct = req.headers.get('content-type') || '';
    let file: File | null = null;

    if (ct.includes('application/json')) {
      const { audioBase64, mimeType } = await req.json();
      if (!audioBase64) return j({ error: 'audioBase64 required' }, 400);
      const buf = Buffer.from(audioBase64, 'base64');
      file = new File([buf], `audio.${ext(mimeType)}`, { type: mimeType || 'audio/webm' });
    } else if (ct.startsWith('multipart/form-data')) {
      const form = await req.formData();
      const f = form.get('file');
      if (!(f instanceof File)) return j({ error: 'file field required' }, 400);
      file = f;
    } else {
      return j({ error: 'Unsupported Content-Type' }, 415);
    }

    const r = await openai.audio.transcriptions.create({
      file: file!, model: 'whisper-1', language: 'en'
    });

    return j({ transcript: r.text ?? '', success: true });
  } catch (e:any) {
    console.error('[whisper] err', e);
    return j({ error: e?.message || 'transcription failed' }, 500);
  }

  function j(x:any, status=200){ return new Response(JSON.stringify(x), { status, headers:{'content-type':'application/json','cache-control':'no-store'} }); }
  function ext(mt?:string){ if(!mt) return 'webm'; if(mt.includes('mp4')) return 'mp4'; if(mt.includes('mpeg')) return 'mp3'; if(mt.includes('wav')) return 'wav'; if(mt.includes('ogg')) return 'ogg'; return 'webm';}
}

// server/routes/whisper-transcription.ts  (Express dev)
import { Router } from 'express';
import { openai } from '../lib/openai';
import multer from 'multer';
const upload = multer(); // memory

const router = Router();

// JSON base64
router.post('/whisper', async (req, res, next) => {
  if ((req.headers['content-type'] || '').includes('application/json')) return next();
  return next('route');
}, async (req, res) => {
  try {
    const { audioBase64, mimeType } = req.body ?? {};
    if (!audioBase64) return res.status(400).json({ error: 'audioBase64 required' });
    const buf = Buffer.from(audioBase64, 'base64');
    const file = new File([buf], `audio.webm`, { type: mimeType || 'audio/webm' });
    const r = await openai.audio.transcriptions.create({ file, model: 'whisper-1', language: 'en' });
    res.json({ transcript: r.text ?? '', success: true });
  } catch (e:any) {
    console.error('[dev whisper] err', e);
    res.status(500).json({ error: e?.message || 'transcription failed' });
  }
});

// multipart fallback
router.post('/whisper', upload.single('file'), async (req, res) => {
  try {
    const f = req.file;
    if (!f) return res.status(400).json({ error: 'file field required' });
    const file = new File([f.buffer], f.originalname || 'audio.webm', { type: f.mimetype || 'audio/webm' });
    const r = await openai.audio.transcriptions.create({ file, model: 'whisper-1', language: 'en' });
    res.json({ transcript: r.text ?? '', success: true });
  } catch (e:any) {
    console.error('[dev whisper/multipart] err', e);
    res.status(500).json({ error: e?.message || 'transcription failed' });
  }
});

export default router;

// server/index.ts  (mount once if not already)
import whisperRouter from './routes/whisper-transcription';
app.use('/api/stt', whisperRouter);

2) Parse freeform — POST /api/workouts/parse-freeform

Prod: api/workouts/parse-freeform.ts

Dev: server/routes/workout-freeform.ts → route POST /api/workouts/parse-freeform

// api/workouts/parse-freeform.ts
import { openai } from '../_openai';
export const config = { runtime: 'nodejs18.x' };

const schema = {
  name: "FreeformParsed",
  schema: {
    type: "object",
    properties: {
      title: { type: "string" },
      est_duration_min: { type: "number" },
      intensity: { type: "number" },
      blocks: {
        type: "array",
        items: {
          type: "object",
          properties: {
            type: { type: "string", enum: ["exercise","round","note"] },
            name: { type: "string" },
            sets: { type: "number", nullable: true },
            reps: { type: "string", nullable: true },
            duration_sec: { type: "number", nullable: true },
            rest_sec: { type: "number", nullable: true },
            notes: { type: "string", nullable: true }
          },
          required: ["type","name"]
        }
      }
    },
    required: ["title","blocks"]
  }
} as const;

export default async function handler(req: Request) {
  if (req.method !== 'POST') return j({ error:'Method Not Allowed' },405);
  let body:{ text?:string };
  try { body = await req.json(); } catch { return j({ error:'Invalid JSON' },400); }
  const text = (body.text||'').slice(0, 12_000);
  if (!text) return j({ error:'text required' },400);

  try {
    const r = await openai.chat.completions.create({
      model: 'gpt-4o-mini',
      temperature: 0.2,
      response_format: { type: 'json_schema', json_schema: { name: schema.name, schema: schema.schema, strict: true } },
      messages: [
        { role: 'system', content: 'Parse workout notes to structured JSON matching the schema. Use reasonable estimates for duration/intensity when missing.' },
        { role: 'user', content: text }
      ]
    });
    const raw = r.choices?.[0]?.message?.content ?? '{}';
    return j({ parsed: JSON.parse(raw), success: true });
  } catch (e:any) {
    console.error('[parse-freeform] err', e);
    return j({ error: e?.message || 'parse failed' }, 500);
  }

  function j(x:any, s=200){ return new Response(JSON.stringify(x),{status:s,headers:{'content-type':'application/json','cache-control':'no-store'}}); }
}

// server/routes/workout-freeform.ts  (Express dev)
import { Router } from 'express';
import { openai } from '../lib/openai';
const router = Router();

router.post('/parse-freeform', async (req, res) => {
  const text = String(req.body?.text || '').slice(0, 12_000);
  if (!text) return res.status(400).json({ error:'text required' });
  try {
    const r = await openai.chat.completions.create({
      model: 'gpt-4o-mini',
      temperature: 0.2,
      response_format: { type: 'json_object' },
      messages: [
        { role: 'system', content: 'Return strict JSON with keys: title, est_duration_min, intensity, blocks[] {type,name,sets,reps,duration_sec,rest_sec,notes}' },
        { role: 'user', content: text }
      ]
    });
    const parsed = JSON.parse(r.choices?.[0]?.message?.content ?? '{}');
    res.json({ parsed, success: true });
  } catch (e:any) {
    console.error('[dev/parse] err', e);
    res.status(500).json({ error: e?.message || 'parse failed' });
  }
});

export default router;

// server/index.ts
import workoutFreeformRouter from './routes/workout-freeform';
app.use('/api/workouts', workoutFreeformRouter);

3) Log freeform — POST /api/workouts/log-freeform

Prod: api/workouts/log-freeform.ts

Dev: add route to server/routes/workout-freeform.ts

// api/workouts/log-freeform.ts
import { supabaseFromReq } from '../_supabase';
export const config = { runtime: 'nodejs18.x' };

export default async function handler(req: Request) {
  if (req.method !== 'POST') return j({ error:'Method Not Allowed' },405);
  const sb = supabaseFromReq(req);
  let body:any; try { body = await req.json(); } catch { return j({ error:'Invalid JSON' },400); }
  const { parsed, title } = body ?? {};
  if (!parsed) return j({ error:'parsed required' },400);

  // Get user (RLS)
  const { data: user } = await sb.auth.getUser();
  if (!user?.user) return j({ error: 'Unauthorized' }, 401);

  // Store minimal + original parsed payload in request (safe for unknown columns)
  const { data, error } = await sb.from('workouts').insert({
    user_id: user.user.id,
    title: title || parsed.title || 'Freeform workout',
    request: parsed,
    completed: true
  }).select('id').single();

  if (error) return j({ error: error.message }, 400);
  return j({ id: data.id, success: true });

  function j(x:any,s=200){ return new Response(JSON.stringify(x),{status:s,headers:{'content-type':'application/json','cache-control':'no-store'}}); }
}

// server/routes/workout-freeform.ts  (append; Express dev)
import { supabaseFromReq } from '../lib/supabaseFromReq';

router.post('/log-freeform', async (req, res) => {
  const sb = supabaseFromReq(req);
  const { parsed, title } = req.body ?? {};
  const { data: user } = await sb.auth.getUser();
  if (!user?.user) return res.status(401).json({ error: 'Unauthorized' });

  try {
    const { data, error } = await sb.from('workouts').insert({
      user_id: user.user.id,
      title: title || parsed?.title || 'Freeform workout',
      request: parsed,
      completed: true
    }).select('id').single();
    if (error) return res.status(400).json({ error: error.message });
    res.json({ id: data.id, success: true });
  } catch (e:any) {
    console.error('[dev/log] err', e);
    res.status(500).json({ error: e?.message || 'log failed' });
  }
});
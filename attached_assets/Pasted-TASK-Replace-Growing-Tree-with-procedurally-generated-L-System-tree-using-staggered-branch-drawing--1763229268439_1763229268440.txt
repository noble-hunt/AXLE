TASK: Replace Growing Tree with procedurally generated L-System tree using staggered branch drawing and fluttering leaves.

VISUAL REFERENCE: https://animejs.com/ - homepage grid of dots with staggered scale/opacity animations

REQUIREMENTS:
1. Generate tree structure using L-System algorithm (iterations based on streakWeeks)
2. Animate branch drawing using strokeDashoffset technique with stagger
3. Leaves appear at branch endpoints with scale + opacity fade-in
4. Leaves sway gently in wind (translateX oscillation)
5. Root system mirrors branches downward with brown/dark gradient
6. Branches thicken based on hierarchy (trunk thickest, twigs thinnest)

IMPLEMENTATION DETAILS:
L-System generation:
function generateLSystem(iterations: number): string {
let axiom = "F";
const rules = { F: "F[+F]F[-F]F" }; // F=forward, +=rotate 25°, -=rotate -25°, [=push, ]=pop
for (let i = 0; i < iterations; i++) {
axiom = axiom.split('').map(char => rules[char] || char).join('');
}
return axiom;
}
function lSystemToPath(lString: string): { branches: Array<{path: string, level: number}>, leafPos: Array<{x,y}> } {
let x = 50, y = 100, angle = -90;
const stack = [];
const branches = [];
const leafPos = [];
let currentPath = M${x},${y};
let level = 0;
for (let char of lString) {
if (char === 'F') {
const newX = x + Math.cos(angle * Math.PI/180) * 5;
const newY = y + Math.sin(angle * Math.PI/180) * 5;
currentPath +=  L${newX},${newY};
x = newX;
y = newY;
} else if (char === '+') {
angle += 25;
} else if (char === '-') {
angle -= 25;
} else if (char === '[') {
stack.push({x, y, angle, path: currentPath, level});
level++;
} else if (char === ']') {
branches.push({path: currentPath, level});
leafPos.push({x, y});
const state = stack.pop();
x = state.x; y = state.y; angle = state.angle;
currentPath = state.path;
level = state.level;
}
}
return { branches, leafPos };
}

Branch animation:
```tsx
const { branches, leafPos } = lSystemToPath(generateLSystem(Math.floor(streakWeeks / 2)));

useEffect(() => {
  // Animate each branch with stagger
  const timeline = window.anime.timeline();
  
  branches.forEach((branch, i) => {
    const pathLength = /* calculate path length */;
    timeline.add({
      targets: `.branch-${i}`,
      strokeDashoffset: [pathLength, 0],
      duration: 800,
      easing: 'easeInOutQuad'
    }, i * 100); // Stagger by 100ms
  });
  
  // Then animate leaves
  timeline.add({
    targets: '.leaf',
    scale: [0, 1],
    opacity: [0, 0.9],
    duration: 600,
    delay: anime.stagger(50),
    easing: 'easeOutElastic(1, .6)'
  });
}, [streakWeeks]);
```

Leaf sway animation:
```tsx
useEffect(() => {
  window.anime({
    targets: '.leaf',
    translateX: () => window.anime.random(-3, 3),
    translateY: () => window.anime.random(-1, 1),
    duration: () => window.anime.random(2000, 4000),
    easing: 'easeInOutSine',
    loop: true,
    direction: 'alternate'
  });
}, []);
```

Render structure:
```tsx
<svg viewBox="0 0 100 120" className="w-80 h-96">
  {/* Branches */}
  {branches.map((b, i) => (
    <path
      key={i}
      className={`branch-${i}`}
      d={b.path}
      stroke="#8b4513"
      strokeWidth={Math.max(1, 4 - b.level)}
      fill="none"
      strokeDasharray={pathLength}
      strokeDashoffset={pathLength}
    />
  ))}
  
  {/* Leaves */}
  {leafPos.slice(0, goodSleepNights).map((pos, i) => (
    <circle
      key={i}
      className="leaf"
      cx={pos.x}
      cy={pos.y}
      r="3"
      fill="#4ade80"
      opacity="0"
    />
  ))}
  
  {/* Mirror for roots (transform: scale(1, -1)) */}
  <g transform="translate(0, 100) scale(1, -1)">
    {/* Same branches but brown gradient */}
  </g>
</svg>
```

Make sure to calculate actual SVG path lengths for strokeDasharray/offset.
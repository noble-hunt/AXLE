Fitbit provider (OAuth + fetch + revoke)

Create server/providers/health/fitbit.ts

// server/providers/health/fitbit.ts
import type { HealthProvider } from './types';
import { verifyState, signState } from '../../lib/oauthState';
import {
  upsertWearableTokenForUser,
  getWearableTokenForUser,
  deleteWearableTokenForUser,
} from '../../dal/tokens';
import { upsertWearableConnection } from '../../dal/wearables';

const FITBIT_AUTH = 'https://www.fitbit.com/oauth2/authorize';
const FITBIT_TOKEN = 'https://api.fitbit.com/oauth2/token';
const FITBIT_REVOKE = 'https://api.fitbit.com/oauth2/revoke';
const FITBIT_API = 'https://api.fitbit.com';

const SITE = process.env.VITE_SITE_URL || process.env.SITE_URL || 'https://axle-ebon.vercel.app';
const REDIRECT = `${SITE}/api/connect/Fitbit/callback`;

// Minimal scopes to get activity, heart rate, sleep & profile
const SCOPES = [
  'activity',      // steps, calories
  'heartrate',     // resting HR
  'sleep',         // sleep + (score in v1.2 endpoints)
  'profile'
].join(' ');

export class FitbitHealthProvider implements HealthProvider {
  id: HealthProvider['id'] = 'Fitbit';

  hasConfig() {
    return !!(process.env.FITBIT_CLIENT_ID && process.env.FITBIT_CLIENT_SECRET);
  }

  async authStart(userId: string) {
    if (!this.hasConfig()) throw new Error('Fitbit not configured');
    const state = signState({ userId, t: Date.now() });
    const params = new URLSearchParams({
      response_type: 'code',
      client_id: process.env.FITBIT_CLIENT_ID!,
      redirect_uri: REDIRECT,
      scope: SCOPES,
      state,
      // Fitbit recommends PKCE for public apps; for MVP we use confidential client on server
    });
    return { redirectUrl: `${FITBIT_AUTH}?${params.toString()}` };
  }

  async authCallback(params: Record<string, string>) {
    const { code, state } = params;
    if (!code || !state) throw new Error('Missing code/state');
    const { userId } = verifyState(state);

    const body = new URLSearchParams({
      client_id: process.env.FITBIT_CLIENT_ID!,
      grant_type: 'authorization_code',
      redirect_uri: REDIRECT,
      code,
    }).toString();

    const tokenRes = await fetch(FITBIT_TOKEN, {
      method: 'POST',
      headers: {
        'content-type': 'application/x-www-form-urlencoded',
        // Fitbit uses Basic auth with client creds on token endpoint
        Authorization:
          'Basic ' +
          Buffer.from(
            `${process.env.FITBIT_CLIENT_ID}:${process.env.FITBIT_CLIENT_SECRET}`
          ).toString('base64'),
      },
      body,
    });
    const tokens = await tokenRes.json();
    if (!tokenRes.ok) throw new Error(tokens?.errors?.[0]?.message || 'token exchange failed');

    await upsertWearableTokenForUser(userId, 'Fitbit', {
      access_token: tokens.access_token,
      refresh_token: tokens.refresh_token,
      expires_at: tokens.expires_in ? Date.now() + tokens.expires_in * 1000 : null,
      scope: tokens.scope,
      token_type: tokens.token_type,
      user_id: tokens.user_id, // Fitbit returns encoded user id
    });
    await upsertWearableConnection(userId, 'Fitbit', { status: 'connected', last_error: null });
  }

  private async ensureToken(userId: string) {
    const t = await getWearableTokenForUser(userId, 'Fitbit');
    if (!t?.access_token) throw new Error('Not connected');

    // Refresh if close to expiry (within 2 min)
    if (t.expires_at && Date.now() > t.expires_at - 120_000 && t.refresh_token) {
      const body = new URLSearchParams({
        grant_type: 'refresh_token',
        refresh_token: t.refresh_token,
      }).toString();
      const res = await fetch(FITBIT_TOKEN, {
        method: 'POST',
        headers: {
          'content-type': 'application/x-www-form-urlencoded',
          Authorization:
            'Basic ' +
            Buffer.from(
              `${process.env.FITBIT_CLIENT_ID}:${process.env.FITBIT_CLIENT_SECRET}`
            ).toString('base64'),
        },
        body,
      });
      const j = await res.json();
      if (res.ok) {
        await upsertWearableTokenForUser(userId, 'Fitbit', {
          access_token: j.access_token,
          refresh_token: j.refresh_token ?? t.refresh_token,
          expires_at: j.expires_in ? Date.now() + j.expires_in * 1000 : t.expires_at,
          scope: j.scope ?? t.scope,
          token_type: j.token_type ?? t.token_type,
          user_id: t.user_id,
        });
        return j.access_token as string;
      }
      // if refresh fails, fall through and try with old token (may 401)
    }
    return t.access_token as string;
  }

  async fetchLatest(userId: string) {
    const access = await this.ensureToken(userId);
    const auth = { Authorization: `Bearer ${access}` };

    const today = new Date();
    const yyyy = today.getFullYear();
    const mm = String(today.getMonth() + 1).padStart(2, '0');
    const dd = String(today.getDate()).padStart(2, '0');
    const d = `${yyyy}-${mm}-${dd}`;

    // Activity (steps, calories)
    const actRes = await fetch(`${FITBIT_API}/1/user/-/activities/date/${d}.json`, { headers: auth });
    const act = await actRes.json();

    // Resting HR from heart summary
    const hrRes = await fetch(`${FITBIT_API}/1/user/-/activities/heart/date/${d}/1d.json`, { headers: auth });
    const hr = await hrRes.json();

    // Sleep (score available on v1.2 endpoints)
    const sleepRes = await fetch(`${FITBIT_API}/1.2/user/-/sleep/date/${d}.json`, { headers: auth });
    const sleep = await sleepRes.json();

    // HRV daily is not universally available; leave null if missing
    let hrv_ms: number | null = null;
    try {
      const hrvRes = await fetch(`${FITBIT_API}/1/user/-/hrv/date/${d}/1d.json`, { headers: auth });
      if (hrvRes.ok) {
        const hrv = await hrvRes.json();
        // pick a reasonable field if present
        const v = hrv?.hrv?.[0]?.value?.dailyRmssd; // rmssd ms (if returned)
        hrv_ms = typeof v === 'number' ? v : null;
      }
    } catch {}

    const steps = act?.summary?.steps ?? null;
    const calories =
      act?.summary?.caloriesOut ??
      act?.summary?.calories ??
      null;
    const resting_hr_bpm = hr?.['activities-heart']?.[0]?.value?.restingHeartRate ?? null;
    const sleep_score =
      sleep?.summary?.['stages']?.score ??
      sleep?.sleep?.[0]?.score ??
      null;

    const snapshot = {
      provider: 'Fitbit' as const,
      date: d,
      hrv_ms,
      resting_hr_bpm,
      sleep_score,
      stress_0_10: null as number | null,
      steps,
      calories,
      raw: { act, hr, sleep },
    };

    return snapshot;
  }

  // Optional helper if you add disconnect route
  async revoke(userId: string) {
    const t = await getWearableTokenForUser(userId, 'Fitbit');
    if (!t?.access_token) return;

    await fetch(FITBIT_REVOKE, {
      method: 'POST',
      headers: {
        'content-type': 'application/x-www-form-urlencoded',
        Authorization:
          'Basic ' +
          Buffer.from(
            `${process.env.FITBIT_CLIENT_ID}:${process.env.FITBIT_CLIENT_SECRET}`
          ).toString('base64'),
      },
      body: new URLSearchParams({ token: t.access_token }).toString(),
    }).catch(() => {});

    await deleteWearableTokenForUser(userId, 'Fitbit');
    await upsertWearableConnection(userId, 'Fitbit', { status: 'disconnected', last_error: null });
  }
}


Notes
• HRV endpoint availability varies; we guard it and default to null.
• Sleep “score” field differs across accounts; we attempt both summary.stages.score and first log’s score.
• If Fitbit later 401s, your DAL will still store the error via sync path; that’s fine for MVP.
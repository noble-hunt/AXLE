Backend routes: implement/restore “suggest today” + “start” + JSON-only guard

Goal:

Provide a clear JSON API to fetch today’s suggestion and start it.

Ensure Express returns JSON for API routes (never SPA HTML), and that API routes are registered before the SPA fallback.

Do:

Edit server/index.ts (or your Express bootstrap): ensure order is:

// JSON / CORS / auth middlewares...
app.use(express.json())

// --- API ROUTES MUST BE MOUNTED BEFORE STATIC SPA ---
app.use('/api', apiRouter) // your main API router

// Static + SPA fallback LAST:
app.use(express.static(path.join(__dirname, '..', 'dist')))
app.get('*', (_, res) => {
  res.sendFile(path.join(__dirname, '..', 'dist', 'index.html'))
})


Add/verify routes in server/routes/workouts.ts (or similar).

The exact internals should use your existing generator/save utilities.

If there isn’t a suggestion table, compute an on-the-fly suggestion using the current “focus picker” heuristic.

// PSEUDO – tailor to your services & Drizzle schema
import { Router } from 'express'
import { ensureAuth } from '../lib/auth'
import { computeTodaySuggestion, startSuggestion } from '../services/suggestions'

const r = Router()

r.get('/suggest/today', ensureAuth, async (req, res, next) => {
  try {
    const userId = req.user.id
    const suggestion = await computeTodaySuggestion(userId) // { focus, rationale, seed?, config }
    res.json({ suggestion })
  } catch (e) { next(e) }
})

r.post('/suggest/today/start', ensureAuth, async (req, res, next) => {
  try {
    const userId = req.user.id
    const { workoutId } = await startSuggestion(userId) // generate + persist + return id
    res.status(201).json({ workoutId })
  } catch (e) { next(e) }
})

export default r


Create server/services/suggestions.ts that calls into your existing generator/save pipeline (the agent should search your repo for the generator used by /api/workouts/generate and reuse it):

// PSEUDO – wire into your real generator
import { generateWorkout } from '../workouts/generator'
import { saveWorkout } from '../workouts/persistence'

export async function computeTodaySuggestion(userId: string) {
  // pull recent history, fatigue, focus preference; or default to balanced
  const config = await buildConfigFromUserSignals(userId) // agent: implement
  const rationale = buildRationale(config)               // agent: implement small helper
  return { config, rationale }
}

export async function startSuggestion(userId: string) {
  const { config } = await computeTodaySuggestion(userId)
  const workout = await generateWorkout(config)
  const workoutId = await saveWorkout(userId, workout)
  return { workoutId }
}


Add a JSON-only guard middleware so we never return HTML to /api/* (prevents “HTML instead of JSON” regressions):

// server/middleware/accept-json.ts
export function requireJSON(req, res, next) {
  if (!req.path.startsWith('/api/')) return next()
  res.setHeader('Vary', 'Accept')
  // If client didn't ask for HTML, we treat as API
  return next()
}


(If you already have proper route ordering, this may be unnecessary; but keep it if you’ve ever seen SPA HTML bleed into API.)

Verify:

# Local (Replit) API checks
curl -i http://localhost:5000/api/workouts/suggest/today
# expect 200 JSON

curl -i -X POST http://localhost:5000/api/workouts/suggest/today/start
# expect 201 JSON { workoutId }

# Confirm Vercel proxy returns JSON (not HTML) if you proxy there later
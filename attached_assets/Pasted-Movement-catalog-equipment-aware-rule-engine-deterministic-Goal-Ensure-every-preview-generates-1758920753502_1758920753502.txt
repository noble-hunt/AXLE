Movement catalog + equipment-aware rule engine (deterministic)

Goal: Ensure every preview generates actual exercises that respect focus, duration, intensity, and available equipment.

Create server/workouts/movements.ts (seed catalog; add ~60 entries—agent can expand):

import { Movement } from "../../shared/workoutSchema";

export const MOVEMENTS: Movement[] = [
  // Bodyweight
  { id:"air-squat", name:"Air Squat", equipment:["bodyweight"], tags:["lower","squat","warmup"] },
  { id:"pushup", name:"Push-up", equipment:["bodyweight"], tags:["upper","push","core"] },
  { id:"reverse-lunge", name:"Reverse Lunge", equipment:["bodyweight"], tags:["lower","lunge"] },
  { id:"plank", name:"Plank", equipment:["bodyweight"], tags:["core","iso"] },
  { id:"burpee", name:"Burpee", equipment:["bodyweight"], tags:["conditioning","full"] },

  // Dumbbell
  { id:"db-bench", name:"DB Bench Press", equipment:["dumbbell"], tags:["upper","push","strength"] },
  { id:"db-row", name:"DB Row", equipment:["dumbbell"], tags:["upper","pull","strength"] },
  { id:"db-rdl", name:"DB RDL", equipment:["dumbbell"], tags:["hinge","lower","strength"] },
  { id:"db-goblet-squat", name:"Goblet Squat", equipment:["dumbbell"], tags:["squat","lower","strength"] },
  { id:"db-thruster", name:"DB Thruster", equipment:["dumbbell"], tags:["full","conditioning"] },

  // Kettlebell
  { id:"kb-swing", name:"KB Swing", equipment:["kettlebell"], tags:["hinge","conditioning"] },
  { id:"kb-clean", name:"KB Clean", equipment:["kettlebell"], tags:["pull","power"] },
  { id:"kb-front-squat", name:"KB Front Squat", equipment:["kettlebell"], tags:["squat","lower"] },
  { id:"kb-push-press", name:"KB Push Press", equipment:["kettlebell"], tags:["push","upper","power"] },

  // Barbell
  { id:"bb-back-squat", name:"Back Squat", equipment:["barbell"], tags:["squat","lower","strength"] },
  { id:"bb-deadlift", name:"Deadlift", equipment:["barbell"], tags:["hinge","lower","strength"] },
  { id:"bb-bench", name:"Bench Press", equipment:["barbell"], tags:["push","upper","strength"] },
  { id:"bb-ohp", name:"Overhead Press", equipment:["barbell"], tags:["push","upper","strength"] },
];


Create server/workouts/rand.ts (seeded RNG):

export function mulberry32(seed: number) {
  return function() {
    let t = (seed += 0x6D2B79F5);
    t = Math.imul(t ^ (t >>> 15), t | 1);
    t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
    return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
  };
}
export function strSeed(s: string) {
  let h = 2166136261 >>> 0;
  for (let i=0;i<s.length;i++) { h ^= s.charCodeAt(i); h = Math.imul(h, 16777619); }
  return h >>> 0;
}


Create server/workouts/generate.ts (rule templates):

import { MOVEMENTS } from "./movements";
import { WorkoutPlan, WorkoutPlanZ, BlockZ } from "../../shared/workoutSchema";
import { mulberry32, strSeed } from "./rand";

type Input = {
  focus: WorkoutPlan["focus"];
  durationMin: number;
  intensity: number;         // 1..10
  equipment: string[];       // ["dumbbell","kettlebell"] etc. may be empty
  seed: string;              // hex/word
};

function pick<T>(rng:()=>number, arr: T[]) { return arr[Math.floor(rng()*arr.length)]; }

function filterByEquipment(allowed: string[]) {
  const set = new Set(allowed.length ? allowed : ["bodyweight"]);
  return MOVEMENTS.filter(m => m.equipment.some(e => set.has(e)));
}

function chooseByTags(pool: ReturnType<typeof filterByEquipment>, tags: string[], rng:()=>number, n: number) {
  const cands = pool.filter(m => tags.some(t => m.tags.includes(t)));
  const out: typeof pool = [];
  const bag = [...cands];
  for (let i=0; i<n && bag.length; i++) {
    out.push(bag.splice(Math.floor(rng()*bag.length), 1)[0]);
  }
  return out.length ? out : pool.slice(0, Math.max(1, n));
}

// map intensity to prescriptions
function doseStrength(intensity: number) {
  // simple mapping
  if (intensity >= 8) return { sets: 5, reps: 3, restSec: 150, load: "RPE 9" };
  if (intensity >= 6) return { sets: 5, reps: 5, restSec: 120, load: "RPE 8" };
  if (intensity >= 4) return { sets: 4, reps: 8, restSec: 90,  load: "RPE 7" };
  return { sets: 3, reps: 10, restSec: 60, load: "RPE 6" };
}
function doseConditioning(intensity: number) {
  // 30–60s work, 10–30s rest
  const work = intensity >= 8 ? 45 : intensity >= 6 ? 40 : 30;
  const rest = intensity >= 8 ? 15 : intensity >= 6 ? 20 : 30;
  return { sets: 10, seconds: work, restSec: rest };
}

export function generatePlan(input: Input): WorkoutPlan {
  const seedN = strSeed(input.seed || `${input.focus}:${input.durationMin}:${input.intensity}:${input.equipment.join(",")}`);
  const rng = mulberry32(seedN);
  const pool = filterByEquipment(input.equipment);

  // split duration: 20% warmup, 70% main, 10% cooldown
  const totalSec = input.durationMin * 60;
  const warmSec = Math.max(300, Math.round(totalSec * 0.2));
  const mainSec = Math.max(600, Math.round(totalSec * 0.7));
  const coolSec = Math.max(180, totalSec - warmSec - mainSec);

  const blocks: z.infer<typeof BlockZ>[] = [];

  // WARMUP
  const wuMoves = chooseByTags(pool, ["warmup","core","mobility"], rng, 2);
  blocks.push({
    key: "warmup",
    title: "Warm-up",
    targetSeconds: warmSec,
    style: "interval",
    items: wuMoves.map(m => ({
      movementId: m.id,
      name: m.name,
      prescription: { type:"time", sets: 1, seconds: Math.round(warmSec/(wuMoves.length)), load:"bodyweight", restSec: 0 }
    }))
  });

  // MAIN by focus
  if (input.focus === "strength") {
    const picks = chooseByTags(pool, ["squat","hinge","push","pull"], rng, 2);
    const dose = doseStrength(input.intensity);
    blocks.push({
      key:"main",
      title:"Main Strength",
      targetSeconds: mainSec,
      style:"straight-sets",
      items: picks.map(m => ({
        movementId: m.id,
        name: m.name,
        prescription: { type:"reps", sets:dose.sets, reps:dose.reps!, restSec:dose.restSec, load:dose.load }
      }))
    });
  } else if (input.focus === "conditioning") {
    const picks = chooseByTags(pool, ["conditioning","full","hinge","squat","push","pull"], rng, 4);
    const dose = doseConditioning(input.intensity);
    blocks.push({
      key:"main",
      title:"MetCon",
      targetSeconds: mainSec,
      style:"amrap",
      items: picks.map(m => ({
        movementId: m.id,
        name: m.name,
        prescription: { type:"time", sets:dose.sets, seconds:dose.seconds!, restSec:dose.restSec, load: m.equipment.includes("bodyweight") ? "bodyweight" : "moderate" }
      }))
    });
  } else if (input.focus === "endurance") {
    const picks = chooseByTags(pool, ["mono","conditioning","lower"], rng, 1);
    blocks.push({
      key:"main",
      title:"Intervals",
      targetSeconds: mainSec,
      style:"interval",
      items: picks.map(m => ({
        movementId: m.id, name: m.name,
        prescription: { type:"time", sets: 8, seconds: 60, restSec: 30, load:"sustainable" }
      })),
    });
  } else { // mixed
    const sPick = chooseByTags(pool, ["squat","hinge","push","pull"], rng, 1);
    const cPick = chooseByTags(pool, ["conditioning","full"], rng, 2);
    const sd = doseStrength(input.intensity);
    const cd = doseConditioning(input.intensity);
    blocks.push({
      key:"main",
      title:"Mixed",
      targetSeconds: mainSec,
      style:"circuit",
      items: [
        ...sPick.map(m => ({ movementId:m.id, name:m.name, prescription:{ type:"reps", sets:sd.sets, reps:sd.reps!, restSec:sd.restSec, load:sd.load }})),
        ...cPick.map(m => ({ movementId:m.id, name:m.name, prescription:{ type:"time", sets:cd.sets, seconds:cd.seconds!, restSec:cd.restSec }})),
      ]
    });
  }

  // COOLDOWN
  const cdMoves = chooseByTags(pool, ["core","warmup","mobility"], rng, 1);
  blocks.push({
    key:"cooldown",
    title:"Cool-down",
    targetSeconds: coolSec,
    style:"interval",
    items: cdMoves.map(m => ({
      movementId: m.id,
      name: m.name,
      prescription: { type:"time", sets:1, seconds: coolSec, restSec: 0, load:"easy" }
    }))
  });

  const plan: WorkoutPlan = {
    seed: input.seed,
    focus: input.focus,
    durationMin: input.durationMin,
    intensity: input.intensity,
    equipment: input.equipment.length ? input.equipment : ["bodyweight"],
    blocks,
    totalSeconds: warmSec+mainSec+coolSec,
    summary: `${input.focus} session • ${input.durationMin}min • intensity ${input.intensity}/10`,
    version: 1,
  };

  return WorkoutPlanZ.parse(plan);
}


Wire the preview endpoint to use the generator:

// server/routes/workouts.ts
import { z } from "zod";
import { generatePlan } from "../workouts/generate";
import { WorkoutPlanZ } from "../../shared/workoutSchema";

const PreviewInputZ = z.object({
  focus: z.enum(["strength","conditioning","mixed","endurance"]),
  durationMin: z.number().int().min(10).max(120),
  intensity: z.number().int().min(1).max(10),
  equipment: z.array(z.string()).default([]),
  seed: z.string().default(() => Math.random().toString(16).slice(2).toUpperCase()),
});

app.post("/api/workouts/preview", async (req,res) => {
  const input = PreviewInputZ.parse(req.body ?? {});
  const plan = generatePlan(input);
  res.json(plan); // validated non-empty plan
});


Acceptance

For every focus + equipment combination, preview returns blocks with visible items.

Equipment filtering is respected (choose dumbbell movements when only dumbbells are selected, etc.).

Same seed → same plan.
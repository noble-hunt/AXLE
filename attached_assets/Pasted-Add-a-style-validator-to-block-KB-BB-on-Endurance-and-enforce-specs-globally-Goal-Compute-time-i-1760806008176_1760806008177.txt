Add a style validator to block KB/BB on Endurance (and enforce specs globally)

Goal: Compute time-in-style and loaded ratios; ban patterns; require patterns; then hard-fail in strict mode.

Action: Edit server/ai/generators/premium.ts and add/ wire validateStyleAgainstSpec

// server/ai/generators/premium.ts
import { STYLE_SPECS, StyleSpec } from '../config/styleSpecs';

function ratioOf(predicate: (s:any)=>boolean, sets:any[]) {
  const mins = (x:any) => (x.duration || x.time_min || 0) / 60;
  const tot = sets.reduce((s,x)=> s + mins(x), 0) || 1;
  const ok  = sets.filter(predicate).reduce((s,x)=> s + mins(x), 0);
  return ok / tot;
}

function hasPattern(s:any, pats:string[]) {
  const txt = JSON.stringify(s).toLowerCase();
  return pats.some(p => txt.includes(p.toLowerCase()));
}

function validateStyleAgainstSpec(style:string, workout:any, strict:boolean) {
  const spec: StyleSpec | undefined = STYLE_SPECS[style as any];
  if (!spec) return;

  const sets = workout.sets || workout.blocks || [];

  // BAN: no banned patterns in mains
  const mains = sets.filter((b:any)=> (b.is_header !== true));
  if (spec.banMainPatterns && spec.banMainPatterns.length) {
    const bad = mains.find(b => hasPattern(b, spec.banMainPatterns!));
    if (bad) {
      workout.meta = workout.meta || {};
      workout.meta.acceptance = workout.meta.acceptance || {};
      workout.meta.acceptance.style_ok = false;
      if (strict) throw new Error(`style_banned_pattern:${style}`);
    }
  }

  // REQUIRE: patterns
  if (spec.requirePatterns && spec.requirePatterns.length) {
    const txt = JSON.stringify(sets).toLowerCase();
    const miss = spec.requirePatterns.find(p => !txt.includes(p.toLowerCase()));
    if (miss) {
      workout.meta.acceptance = workout.meta.acceptance || {};
      workout.meta.acceptance.style_ok = false;
      if (strict) throw new Error(`style_required_missing:${style}:${miss}`);
    }
  }

  // RATIO checks (cyclical share / loaded share)
  if (spec.minCyclicalRatio || spec.maxLoadedRatio !== undefined) {
    const cycPats = ["cyclical","cardio","run","row","bike","erg","ski","swim","jump_rope"];
    const loadedPats = ["barbell","dumbbell","kettlebell","thruster","clean","jerk","snatch","deadlift","squat","press","pull","bench"];
    const cycRatio = ratioOf((x)=>hasPattern(x,cycPats), mains);
    const loadedRatio = ratioOf((x)=>hasPattern(x,loadedPats), mains);

    workout.meta.acceptance = workout.meta.acceptance || {};
    if (spec.minCyclicalRatio && cycRatio < spec.minCyclicalRatio) {
      workout.meta.acceptance.style_ok = false;
      if (strict) throw new Error(`style_min_cyclical_ratio_fail:${cycRatio}`);
    }
    if (spec.maxLoadedRatio !== undefined && loadedRatio > spec.maxLoadedRatio) {
      workout.meta.acceptance.style_ok = false;
      if (strict) throw new Error(`style_max_loaded_ratio_fail:${loadedRatio}`);
    }
  }
}


Wire it where we finalize the workout (after fitting & hardness):

// toward the end of premium.ts, just before return
const strict = process.env.HOBH_PREMIUM_STRICT === 'true';
validateStyleAgainstSpec(style, workout, strict);

Client HTTP: never allow empty path, build paths safely, surface real errors

Goal: Kill the “API endpoint / not found” by preventing empty/invalid paths and improving error messages.

Env helper

File: client/src/lib/env.ts

export const API_BASE =
  (import.meta.env.VITE_API_BASE_URL as string | undefined) && import.meta.env.VITE_API_BASE_URL.trim() !== ""
    ? import.meta.env.VITE_API_BASE_URL.replace(/\/+$/, "")
    : ""; // same-origin relative


HTTP helper (safe join & better errors)

File: client/src/lib/http.ts

export class HttpError extends Error {
  status: number;
  body?: any;
  constructor(message:string, status:number, body?:any) { super(message); this.status = status; this.body = body; }
}

function joinApi(path: string) {
  if (!path || path === "/" || typeof path !== "string") {
    throw new HttpError("Invalid API path (empty)", 0);
  }
  if (!path.startsWith("/")) path = `/${path}`;
  return `${API_BASE}${path}`;
}

export async function httpJSON(path: string, init?: RequestInit) {
  const url = joinApi(path);
  const res = await fetch(url, { headers: { "Content-Type":"application/json", ...init?.headers }, ...init });
  const ct = res.headers.get("content-type") || "";
  const isJson = ct.includes("application/json");
  const data = isJson ? await res.json().catch(() => undefined) : await res.text();

  if (!res.ok) {
    const msg = isJson && data?.error
      ? data.error
      : typeof data === "string" && data ? data.slice(0, 200) : `HTTP ${res.status}`;
    throw new HttpError(msg, res.status, data);
  }
  return data;
}


Generator API uses correct path

File: client/src/features/workouts/generator/api.ts

import { httpJSON } from "@/lib/http";

export async function fetchPreview(input: {
  focus: string;
  durationMin: number;
  equipment: string[];
  intensity: number;
  seed?: string;
}) {
  return httpJSON("/api/workouts/preview", {
    method: "POST",
    body: JSON.stringify(input),
  });
}


Toast real message

File: client/src/features/workouts/generator/steps/PreviewGenerate.tsx

try {
  const { preview, seed } = await fetchPreview(payload);
  setPreview(preview); setSeed(seed);
} catch (e:any) {
  const msg = e?.message ?? (e?.status ? `HTTP ${e.status}` : "Preview failed");
  toast({ title: "Preview Failed", description: msg, variant: "destructive" });
}


Acceptance:

If the path is wrong, you’ll now get “Invalid API path (empty)” (no more “/ not found”).

With proxy + server route, preview returns and renders.
Fix “Edit Profile” (columns + RLS + API + client) — STOP after this

Goal
Make “Edit Profile” reliably save first_name, last_name, date_of_birth for the logged-in user. Add missing columns, verify RLS, implement a single PUT API that upserts with onConflict: 'user_id', validates input, and improves error logs.

0) Add a quick diagnostic (temporary)

Create api/debug/profile-check.ts:

import type { VercelRequest, VercelResponse } from '@vercel/node';
import { supabaseAdmin } from '../_lib/supabase'; // existing admin client

export default async function handler(req: VercelRequest, res: VercelResponse) {
  const { data, error } = await supabaseAdmin.rpc('pg_typeof', {} as any)
    .then(() => supabaseAdmin.from('profiles').select('user_id, username, avatar_url, first_name, last_name, date_of_birth').limit(1));
  // We only care about the error shape for unknown columns
  res.status(200).json({ ok: !error, error: error?.message ?? null, columnsPresent: !error });
}

1) DB: extend profiles and add update timestamp

Create migration supabase/migrations/004_profiles_extend.sql:

-- Add new profile fields if missing
alter table public.profiles
  add column if not exists first_name text,
  add column if not exists last_name text,
  add column if not exists date_of_birth date,
  add column if not exists updated_at timestamptz default now();

-- Reasonable DOB guard (optional; adjust age if needed)
alter table public.profiles
  drop constraint if exists profiles_dob_reasonable;
alter table public.profiles
  add constraint profiles_dob_reasonable
  check (date_of_birth is null or date_of_birth between date '1900-01-01' and (current_date - interval '13 years'));

-- Touch updated_at on update
create or replace function public.set_updated_at() returns trigger language plpgsql as $$
begin new.updated_at = now(); return new; end $$;

drop trigger if exists trg_profiles_updated_at on public.profiles;
create trigger trg_profiles_updated_at
before update on public.profiles
for each row execute function public.set_updated_at();

-- RLS (already present but reaffirm for clarity)
-- profiles policy should allow self read/write only:
-- create policy "profiles self access" on public.profiles for all
-- using (user_id = auth.uid()) with check (user_id = auth.uid());


Run the migration in Supabase SQL editor (copy the whole file). Confirm the three new columns exist.

2) Server: stable, validated PUT /api/profile

Create api/profile/index.ts:

import type { VercelRequest, VercelResponse } from '@vercel/node';
import { z } from 'zod';
import { supabaseAdmin } from '../_lib/supabase';
import { requireAuth } from '../_lib/auth';

const Schema = z.object({
  first_name: z.string().trim().max(80).optional().nullable(),
  last_name: z.string().trim().max(80).optional().nullable(),
  date_of_birth: z.string().trim().optional().nullable() // 'YYYY-MM-DD' or ''
}).strict();

function toDateOrNull(s?: string | null) {
  if (!s) return null;
  const m = /^(\d{4})-(\d{2})-(\d{2})$/.exec(s);
  if (!m) return null;
  return s; // Postgres 'date' accepts YYYY-MM-DD
}

export default async function handler(req: VercelRequest, res: VercelResponse) {
  if (req.method !== 'PUT') return res.status(405).json({ message: 'Method Not Allowed' });

  const user = await requireAuth(req, res); if (!user) return;
  let body: any;
  try { body = Schema.parse(req.body ?? {}); }
  catch (e: any) { return res.status(400).json({ message: 'Invalid input', issues: e?.issues }); }

  const patch: any = {
    user_id: user.id,
    first_name: body.first_name ?? null,
    last_name: body.last_name ?? null,
    date_of_birth: toDateOrNull(body.date_of_birth)
  };

  // Upsert on user_id
  const { data, error } = await supabaseAdmin
    .from('profiles')
    .upsert([patch], { onConflict: 'user_id' })
    .select('user_id, first_name, last_name, date_of_birth, updated_at')
    .single();

  if (error) {
    // Log full error to server logs and return detail to client
    console.error('[profile/upsert] error:', error);
    return res.status(500).json({ message: 'Failed to upsert profile', detail: error.message ?? error });
  }

  return res.status(200).json({ profile: data });
}

3) Client: call the API and improve error surface

In your Edit Profile screen, replace any direct supabase.from('profiles').upsert(...) with a single call:

const resp = await authFetch('/api/profile', {
  method: 'PUT',
  headers: { 'Content-Type': 'application/json' },
  body: JSON.stringify({ first_name, last_name, date_of_birth }) // YYYY-MM-DD
});
const json = await resp.json();
if (!resp.ok) throw new Error(json?.detail || json?.message || 'Profile save failed');
toast.success('Profile updated');


Ensure the DOB field stores YYYY-MM-DD (not a JS Date string with time). If you use a date picker, format on save:
format(date, 'yyyy-MM-dd').

Update your hydration to display these fields from profiles (first_name, last_name, date_of_birth).

4) Better client error logging (the red overlay you saw hid the real DB message)

In your throwIfResNotOk helper (e.g., src/lib/queryClient.ts), change to:

export async function throwIfResNotOk(res: Response) {
  if (res.ok) return;
  const text = await res.text().catch(()=>'');
  let info:any = null;
  try { info = text ? JSON.parse(text) : null; } catch { /* keep text */ }
  const msg = info?.detail || info?.message || text || `${res.status} ${res.statusText}`;
  throw new Error(msg);
}

5) Clean up any old code paths

Remove/disable any other “profile upsert” calls that might still point at the old client-side upsert (that’s what likely logged “Profile upserted successfully” twice and then failed).

Ensure only the new PUT /api/profile is used from the “Save” button.

✅ Acceptance (then STOP)

Visit Edit Profile, set First/Last/DOB, click Save → toast “Profile updated”.

Refresh: values persist (hydration shows updated fields).

DB shows non-null first_name, last_name, date_of_birth in public.profiles for your user row.

No red overlay errors; if an error occurs (e.g., bad date), the client shows a meaningful message (from detail).

api/debug/profile-check returns { ok: true } (you can delete this file afterward).